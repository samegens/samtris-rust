use crate::graphics::{Display, TetrominoPattern};
use crate::graphics::{I, J, L, O, S, T, Z};

pub struct HighScoresScreenBackground {
    pattern: TetrominoPattern,
}

impl HighScoresScreenBackground {
    pub fn new() -> Self {
        // Sorry, autoformat makes this look messy.
        let pattern_data = vec![
            vec![
                I, O, O, T, T, T, S, S, T, J, J, J, I, I, I, I, T, Z, Z, I, I, I, I, L, J, -1, T,
                T, T, O, O, -1, T, J, J, J, T, -1, O, O,
            ],
            vec![
                I, O, O, -1, T, S, S, T, T, T, -1, J, T, -1, -1, T, T, T, Z, Z, -1, L, L, L, J, J,
                J, T, -1, O, O, T, T, T, -1, J, T, T, O, O,
            ],
            vec![
                I, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, T, T, T, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, T, -1, L, L,
            ],
            vec![
                I, Z, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, L,
            ],
            vec![
                Z, Z, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, Z, Z, L,
            ],
            vec![
                Z, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, Z, Z,
            ],
            vec![
                O, O, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, O, O,
            ],
            vec![
                O, O, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, O, O,
            ],
            vec![
                J, J, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, S, -1,
            ],
            vec![
                J, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, S, S,
            ],
            vec![
                J, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, T, S,
            ],
            vec![
                T, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, T, T, T,
            ],
            vec![
                T, T, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, L, L,
            ],
            vec![
                T, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, I, L,
            ],
            vec![
                J, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, I, L,
            ],
            vec![
                J, J, J, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, I, -1,
            ],
            vec![
                L, L, L, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, I, Z,
            ],
            vec![
                L, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, Z, Z,
            ],
            vec![
                O, O, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, Z, L,
            ],
            vec![
                O, O, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, L, L, L,
            ],
            vec![
                -1, T, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, O, O,
            ],
            vec![
                T, T, T, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, J, O, O,
            ],
            vec![
                L, L, -1, -1, -1, -1, -1, T, T, T, -1, J, J, -1, S, -1, L, -1, -1, -1, -1, -1, -1,
                -1, -1, J, J, Z, -1, -1, -1, -1, -1, -1, -1, -1, -1, J, J, J,
            ],
            vec![
                -1, L, -1, -1, -1, -1, O, O, T, O, O, J, -1, T, S, S, L, -1, O, O, T, T, T, S, S,
                J, Z, Z, L, L, L, -1, T, T, T, L, L, L, S, S,
            ],
            vec![
                -1, L, I, I, I, I, O, O, -1, O, O, J, T, T, T, S, L, L, O, O, -1, T, S, S, -1, J,
                Z, -1, L, I, I, I, I, T, -1, L, -1, S, S, -1,
            ],
        ];

        Self {
            pattern: TetrominoPattern::new(pattern_data),
        }
    }

    pub fn draw<D: Display + ?Sized>(&self, display: &mut D) -> Result<(), String> {
        // Draw the pattern in the background (top-left corner)
        self.pattern.draw(display, 0, 0)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::graphics::MockDisplay;

    #[test]
    fn high_scores_background_draws_blocks() {
        // Arrange
        let sut = HighScoresScreenBackground::new();
        let mut display = MockDisplay::new();

        // Act
        let result = sut.draw(&mut display);

        // Assert
        assert!(result.is_ok());
        assert!(!display.drawn_blocks.is_empty());
    }

    #[test]
    fn high_scores_background_uses_different_tetromino_types() {
        // Arrange
        let sut = HighScoresScreenBackground::new();
        let mut display = MockDisplay::new();

        // Act
        let result = sut.draw(&mut display);

        // Assert
        assert!(result.is_ok());

        let used_types: std::collections::HashSet<_> = display
            .drawn_blocks
            .iter()
            .map(|(_, tetromino_type)| *tetromino_type)
            .collect();

        assert!(used_types.len() > 1, "Should use multiple tetromino types");
    }
}
